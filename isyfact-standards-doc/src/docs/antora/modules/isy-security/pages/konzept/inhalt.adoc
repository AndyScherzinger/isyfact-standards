= Konzept Security (Sicherheit): Inhalt

// tag::inhalt[]
[[prinzipien-der-sicherheitsarchitektur]]
== Prinzipien der Sicherheitsarchitektur

Die IsyFact-Referenzarchitektur beinhaltet auf der technischen Ebene Vorgaben für die Sicherheitsarchitektur und für die Prinzipien, nach denen sie aufgebaut ist.
Eine davon ist die Forderung, dass IsyFact-konforme IT-Systeme gegen unberechtigte Nutzung zu schützen sind.
Konkret wird das im Baustein `Security` durch ein Rollen-, Rechte- und Berechtigungsmanagement realisiert:

* Authentifizierungsinformationen, wie Benutzername und Passwort, werden nicht über IT-Systeme hinweg weitergegeben.
Nur der Eigentümer der Authentifizierungsinformationen und der IAM-Service besitzen Kenntnis über diese Informationen.
* Die Authentifizierung und grobgranulare Autorisierung (mittels dem Nutzer zugeordneten Rollen) erfolgt an den Außenschnittstellen der Systemlandschaft (Portal, Authentication-Gateway bzw. Service-Gateway).
* Liegt kein Aufruf über eine Außenschnittstelle vor (z.B. bei einem Batch-Aufruf), so geschieht die Authentifizierung und grobgranulare Autorisierung innerhalb der Nutzungsschicht (Batch) des konkreten IT-Systems.
* Die feingranulare Autorisierung geschieht in der Nutzungsschicht und im Anwendungskern der IT-Systeme über den IsyFact-Baustein Security, indem die Nutzerrollen auf anwendungsspezifische Rechte abgebildet werden und diese Rechte bei jedem Serviceaufruf geprüft werden.

Existiert keine Systemlandschaft (d.h. IT-Systeme stehen für sich allein), gilt grundsätzlich, dass die Authentifizierung und grobgranulare Autorisierung in der Nutzungsschicht (GUI, Service oder Batch) des IT-Systems geschehen muss.

Darüber hinaus finden Authentifizierung und Autorisierung nach den Vorgaben des Berechtigungskonzepts statt.

Dieses Dokument beschreibt wesentliche Aspekte der Sicherheitsarchitektur für eine konkrete Anwendungslandschaft.
Da das Berechtigungskonzept individuell für jede Anwendungslandschaft erstellt wird und sich im einzelnen stark von Inhalt und Umfang her unterscheidet, ist es kein Bestandteil des Bausteins Security oder der IsyFact.

[[authentifizierung]]
=== Authentifizierung

NOTE: Authentifikation: Verifikation der Identität eines Benutzers (menschl. xref:glossary:glossary:master.adoc#glossar-anwender[Anwender] oder techn. System) als Zugangskontrolle zu einem geschützten System - durch Präsentation eindeutiger Eigenschaften (z.B. Biometrie) oder geheimen Wissens (z.B. Passwort) (Authentisierung).

In der Regel erfolgt die Authentifizierung von Benutzern über eine zentrale Komponente der Systemlandschaft, in welche das IT-System eingebettet ist.
Die Authentifizierung darf auch lokal, d.h. vom IT-System selbst, durchgeführt werden, falls es beispielsweise nicht in eine Systemlandschaft eingebettet ist.

Für die zentrale Authentifizierung wird in der IsyFact ein OAuth 2.0 konformes IAM-System verwendet.

NOTE: IAM steht für xref:glossary:literaturextern:inhalt.adoc#litextern-identity_management[Identity and Access Management].

Das IAM-System verwaltet *Benutzer* (menschl. Anwender oder techn. System) und ihre *Rollen* zentral für alle Komponenten der Anwendungs- und Systemlandschaft.

Die Authentifizierung und grobgranulare Autorisierung erfolgt, gemäß der  xref:konzept/master.adoc#prinzipien-der-sicherheitsarchitektur[Prinzipien der Sicherheitsarchitektur], an den Außenschnittstellen der Systemlandschaft.
Hierbei übermittelt der Benutzer seine Authentifizierungsmerkmale (z.B. Login-Name u. Passwort) an den IAM-Service, der sie gegen die bei ihm gespeicherten Merkmale verifiziert und nach erfolgreicher Authentifizierung sein OK gibt, zusammen mit den bei ihm hinterlegten Rollen des Anwenders. +
Die Rollen allein sind jedoch noch nicht ausreichend, um den Benutzer in der Anwendung vollständig zu autorisieren.

[[autorisierung]]
=== Autorisierung

NOTE: Autorisierung: Zustimmung oder Erlaubnis, spezieller die Einräumung von Rechten gegenüber interessierten Rechtssubjekten, gegebenenfalls als Nutzungsrecht gegenüber Dritten.

Die Autorisierung geschieht in jedem Fall im jeweiligen IT-System.
Nach der erfolgreichen Authentifizierung eines Benutzers leitet das IAM-System die Anfrage an das IT-System weiter bzw. gibt dem Aufrufer das Ergebnis der Authentifizierung zurück - angereichert mit weiteren Informationen über den Benutzer (speziell: zugeordnete Rollen).
Dort wird die Anfrage – je nach Schutzbedarf und Funktionalität – autorisiert.
Dazu weist das IT-System einem Benutzer anhand seiner Rollen anwendungssezifische *Rechte* zu und prüft diese gegen die für die Nutzung des angefragten Service benötigten Rechte.
Wie genau Rollen und Rechte spezifiziert werden, beschreibt das Kapitel xref:konzept/master.adoc#rollen-und-rechte[Rollen und Rechte].

[[oauth2.0-und-openidconnect]]
== OAuth2.0 und OpenIDConnect

OAuth 2.0 ist ein offenes Autorisierungsprotokoll, das eine standardisierte, sichere API-Autorisierung für Desktop-, Web- und Mobile-Anwendungen erlaubt.
Ein (menschlicher) Endbenutzer kann mit Hilfe eines Autorisierungsservers (IAM-Service) einer Anwendung den Zugriff auf seine (geschützten) Daten erlauben (Autorisierung), die von einem anderen Service bereitgestellt werden, ohne geheime Details seiner Zugangsberechtigung (Authentifizierung) der Anwendung preiszugeben.
Der Endbenutzer kann so der Anwendung gestatten, in seinem Namen einen Service zu benutzen.
Dazu wird der Endbenutzer auf eine Login-Seite des Autorisierungsservers (IAM-Service) umgeleitet und nach erfolgreicher Authentifizierung zurück in die Anwendung.
Dabei wird die Übermittlung von vertraulichen Daten wie z.B. Passwörtern an die Anwendung vermieden.
Bei M2M-Kommunikation (Machine to Machine) enthält die Konfiguration der Anwendung die zur Authentifizierung notwendigen Daten des dafür verwendeten technischen Nutzers (Client, die direkt an den IAM-Service geschickt werden.
Bei erfolgreicher Authentifizierung erhält die Anwendung ein Access-Token (Zugriffstoken), eine Art 'Freibrief' für die Anwendung, mit dem der IAM-Service das Zugangsrecht bestätigt.

OpenID Connect oder OIDC ist ein offenes Identitätsprotokoll, das die Autorisierungs- und Authentifizierungsmechanismen von OAuth 2.0 nutzt und als Schicht oberhalb des OAuth-Frameworks Anwendungen ermöglicht, zusätzlich zur oben beschriebenen Autorisierung auch grundlegende Profilinformationen des Benutzers auf interoperable Weise zu erhalten.
Die Implementierung von OpenID Connect basiert auf der Ausstellung von ID-Tokens und auf der HTTP-Programmierschnittstelle mit REST-Mechanismen und auf dem Datenformat JSON.

[[oauth2.0-zur-autorisierung]]
=== OAuth2.0 zur Autorisierung

OAuth 2.0 ist ein Autorisierungsprotokoll und kein Authentifizierungsprotokoll.
Als Solches ist es in erster Linie dafür vorgesehen, den Zugriff auf bestimmte Ressourcen zu ermöglichen, beispielsweise externe APIs oder Nutzerdaten. +
OAuth 2.0 nutzt Access-Tokens.
Access-Tokens sind Daten, die die Autorisierung zum Zugriff auf Ressourcen für den Endnutzer darstellen.
OAuth 2.0 definiert kein spezielles Format für Zugriffstokens, in der Regel wird jedoch das „JSON Web Token (JWT)“-Format genutzt.
Dieses ermöglicht es dem Aussteller der Access-Tokens, weitere Daten in das Access-Token selbst aufzunehmen.
Aus Sicherheitsgründen sollten Access-Tokens außerdem ein Ablaufdatum besitzen.

In OAuth 2.0 gibt es folgende vier Rollen bzw. beteiligte Parteien:

*Ressourcenbesitzer (Resource Owner)*

Eine Person oder ein System, das berechtigt ist, auf eine geschützte Ressource zuzugreifen. +
Beispiel: Anwender, Techn. Nutzer. +
Wir übernehmen für die IsyFact die konkrete Ausprägung "Anwender", "Techn. Nutzer" "Client".

*Ressourcen-Server bzw. Anwendungssystem (Resource-Server)*

Der Server, in dem die geschützte Ressource liegt und der in der Lage ist, auf Anfragen an diese geschützte Ressource zu reagieren, wenn sie ein Access-Token enthalten. +
Beispiel: Geschäftsanwendung +
Wir übernehmen für die IsyFact die IsyFact-spezifische Bezeichnung "Anwendungssystem".

*Anwendung (Client)*

Eine vom Ressourcenbesitzer gesteuerte Anwendung, die in seinem Namen eine geschützte Ressource verwenden möchte.
Der Begriff 'Client' impliziert hier nicht bestimmte Implementierungscharakteristiken, sondern den Teil der Anwendung, mit der der Ressourcenbesitzer interagiert. +
Beispiel: Batch.  +
Wir übernehmen für die IsyFact die englische Bezeichnung "Client".

*IAM-Service (Authorization-Server)*

Der Service, der Access-Tokens ausstellt, nach erfolgreicher Authentifizierung und Autorisierung des Ressourcenbesitzers.
Er bestätigt auch gegenüber dem Ressourcen-Server die Gültigkeit des Access-Tokens, das der Client dem Ressourcen-Server in der Zugangsanfrage mitgegeben hat.  +
Beispiel: Keycloak (Produkt).  +
Wir übernehmen für die IsyFact die IsyFact-spezifische Bezeichnung "IAM-Service".

Weitere wichtige Begriffe sind:

*Ressource (Resource)*

Daten oder andere Betriebsmittel, die durch ein Nutzungsrecht vor unbefugtem Zugang geschützt sind.  +
Wir übernehmen für die IsyFact die deutsche Bezeichnung "Ressource".

*Zugriffstoken (Access-Token)*

Berechtigungsnachweis für den Zugang zu einer geschützten Ressource.
Der Inhalt ist für den Client meist nicht lesbar, er gibt es einfach weiter an den Ressourcen-Server.
Sie gelten für einen spezifischen Bereich und nur für eine bestimmte Zeit. +
Wir übernehmen für die IsyFact die englische Bezeichnung "Access-Token".

*Aktualisierungstoken (Refresh-Token)*

'Meta'-Berechtigungsnachweis: Ermöglicht dem Client, ein neues Access-Token vom IAM-Service zu erhalten, ohne dass der Ressourcenbesitzer sich erneut ausweisen muss.
Diese neue Access-Token kann z.B. ein späteres Ablaufdatum (autom. Nutzungsverlängerung) oder andere Rechte (innerhalb aller an den Ressourcenbesitzer vergebenen Rechte) aufweisen.  +
Wir übernehmen für die IsyFact die englische Bezeichnung "Refresh-Token".

[[openidconnect-zur-authentifizierung]]
=== OpenIDConnect zur Authentifizierung
OpenID Connect ist eine Identitätsschicht über dem OAuth 2.0-Protokoll und ist eine Erweiterung und nicht Teil des OAuth2.0-Protokolls.
Es ermöglicht Clients, die Identität des Endbenutzers basierend auf der von einem Autorisierungsserver durchgeführten Authentifizierung zu überprüfen und grundlegende Profilinformationen über den Endbenutzer auf interoperable und REST-ähnliche Weise zu erhalten.

OpenID Connect ermöglicht es Clients aller Art, einschließlich webbasierter, mobiler und JavaScript-Clients, Informationen über authentifizierte Sitzungen und Endbenutzer anzufordern und zu erhalten.

Der Baustein `Security` bietet keine direkte OpenID Connect Unterstützung.
Für den Transport von Benutzerinformationen, wie z.B. BHKNZ, wird das Access-Token verwendet.

OpenID Connect Abfragen zur Identität eines Benutzers, OpenID-Token oder Custom-Token müssen in der Anwendung implementiert werden.

[[authentifizierung-und-autorisierung]]
=== Authentifizierung & Autorisierung

[[aufruf-weboberflaeche-portal]]
==== Aufruf Web-Oberfläche/Portal

[[aufruf-service-gateway]]
==== Aufruf Service-Gateway

Mit der `IsyFact 3` wird eine neue Authentifizierungslogik (xref:aufruf-service-gateway-mit-authentication-gateway[]) für die Authentifizierung von Anwendungen, die außerhalb der Anwendungslandschaft betrieben werden, eingeführt.
Für eine weiche Migration der externen Anwendungen auf die neue IsyFact-Version wird zusätzlich die bisherige Authentifizierungslogik (xref:aufruf-service-gateway-ohne-authentication-gateway[]) beibehalten.

[[aufruf-service-gateway-mit-authentication-gateway]]
===== Direkte Authentifizierung am IAM-Service

Die folgende Abbildung zeigt die neue System-Architektur, die bei Aufrufen von externen Anwendungen zum Einsatz kommt.
Dabei werden die Aufrufe mit Authentifizierungsdaten von Aufrufen mit Nutzungsdaten getrennt.
Die Authentifizierungsaufrufe werden über das _Authentication-Gateway_ geleitet, wohingegen die Aufrufe mit den Nutzdaten über das _ServiceGateway (SGW)_ geleitet werden.

.Authentifizierung am Authentication-Gateway
[id="image-servicegateway-plus-authgateway",reftext="{figure-caption} {counter:figures}"]
image::isy-security:konzept/ServiceGateway_plus_AuthGateway.dn.svg[align="center"]

Damit ein Client einer externen Anwendung auf die Ressourcen einer Anwendung zugreifen kann, benötigt er ein gültiges Access-Token.
Dieses Token muss sich der Client zuerst beschaffen, indem er sich beim _IdentityAccessManagement-Service (IAM-Service)_ authentifiziert.
Mit der Einführung des _Authentication-Gateways_ werden somit alle Anfragen mit Authentifizierungsdaten über einen separaten Kommunikationskanal geleitet.
Damit kommt keine mit der Authentifizierung involvierte Komponente mit späteren Anwendungsanfragen in Kontakt und umgekehrt.

Die externe Anwendung sendet ihre Authentifizierungsdaten an das _Authentication-Gateway_, das die Anfrage an den IAM-Service weiterleitet.
Im IAM-Service erfolgt dann mit den übergebenen Authentifizierungsdaten die eigentliche Authentifizierung.
Dabei wird neben der neuen Authentifizierungslogik des _Client-Credential-Flows_ auch die bisherige Authentifizierungslogik des _Resource-Owner-Password-Credentials-Flows_ unterstützt.
Der _Client-Credential-Flow_ dient dabei der Authentifizierung eines techn. Nutzers und über den _Resource-Owner-Password-Credentials-Flow_ erfolgt die Authentifizierung eines Anwenders.
Mit validen Authentifizierungsdaten und erfolgreicher Authentifizierung liefert der IAM-Service dann ein valides, neu erstelltes Access-Token an die externe Anwendung zurück.

Mit Erhalt eines gültigen Access-Tokens kann nun die externe Anwendung ihre fachlichen Aufrufe zusammen mit dem Token über das _Service-Gateway_ an das eigentliche Anwendungssystem senden.
Denn in dem Access-Token sind alle notwendigen Informationen enthalten, um im _Service-Gateway_ eine Validierung auf eine zuvor stattgefundene und gültige Authentifizierung, sowie eine Prüfung auf eine valide Autorisierung des Requests vorzunehmen.
So sind neben einer Gültigkeitsdauer auch die für den Benutzer autorisierten Rollen in dem Token enthalten, sodass im Anwendungssystem die Ausführungsberechtigung des Benutzers verifiziert und sichergestellt werden kann.

Das nachfolgende Sequenzdiagramm zeigt noch einmal schematisch den logischen Ablauf der Authentifizierung und Autorisierung im Zusammenspiel der System-Komponenten und dem Authentication-Gateway:

.Sequenzdiagramm Authentifizierung am Authentication-Gateway
[id="image-sequenzdiagramm-sgw-plus-agw",reftext="{figure-caption} {counter:figures}"]
image::isy-security:konzept/Squenzdiagramm_ServiceGateway_plus_AuthGateway.dn.svg[align="center"]


[[aufruf-service-gateway-ohne-authentication-gateway]]
===== Authentifizierung über das SGW am IAM-Service

Die nachfolgende Abbildung zeigt die System-Architektur, die bei Aufrufen von externen Anwendungen für die Authentifizierung ohne _Authentication-Gateway_ zum Einsatz kommt.
Diese Authentifzierungs- und Autorisierungs-Variante wird aus Vereinfachungsgründen der Migration von externen Anwendungen auf die neue `IsyFact Version-3` zusätzlich beibehalten, da hierdurch die Umstellungsaufwände reduziert werden.

So muss der verwendete techn. Nutzer für diese externe Anwendung noch nicht gemäß _SpringSecurity (OAuth2.0)_ auf einen _OAuth2.0 Client_ migriert worden sein, sondern es kann nach wie vor ein techn. Nutzer zur Authentifizierung verwendet werden.
Zusätzlich kann die externe Anwendung den gleichen Kommunikationskanal für die Authentifizierung verwenden, wie für ihre fachlichen Anfragen.

.Authentifizierung ohne Authentication-Gateway
[id="image-servicegateway-ohne-authgateway",reftext="{figure-caption} {counter:figures}"]
image::isy-security:konzept/ServiceGateway-Authentifizierung.dn.svg[align="center"]

Für den Zugriff auf die Ressourcen eines Anwendungssystems benötigt die externe Anwendung ein gültiges Access-Token.
Dieses Token muss sich die Anwendung zuerst beschaffen, indem sie sich beim _IdentityAccessManagement-Service (IAM-Service)_ authentifiziert.

Eingehende Authentifizierungsanfragen werden hierbei im _Service-Gateway_ erkannt und mit den übergebenen Authentifizierungsdaten an den _IAM-Service_ weitergeleitet.

Im IAM-Service erfolgt dann mit den übergebenen Authentifizierungsdaten die eigentliche Authentifizierung.
Dabei wird neben der neuen Authentifizierungslogik des _Client-Credential-Flows_ auch die bisherige Authentifizierungslogik des _Resource-Owner-Password-Credentials-Flows_ unterstützt.
Der _Client-Credential-Flow_ dient dabei der Authentifizierung eines Clients und über den _Resource-Owner-Password-Credentials-Flow_ erfolgt die Authentifizierung eines techn. Nutzers.
Mit validen Authentifizierungsdaten und erfolgreicher Authentifizierung liefert der IAM-Service dann ein valides, neu erstelltes Access-Token an das Service-Gateway zurück.

Mit Erhalt eines gültigen Access-Tokens leitet das Service-Gateway die fachliche Anfrage zusammen mit dem Token an das eigentliche Anwendungssystem weiter.
In der Anwendung kann anschließend die Ausführungsberechtigung des Benutzers verifiziert und sichergestellt werden.

Das nachfolgende Sequenzdiagramm zeigt schematisch den logischen Ablauf der Authentifizierung und Autorisierung im Zusammenspiel der System-Komponenten mit dem _Service-Gateway_ aber ohne _Authentication-Gateway_:

.Sequenzdiagramm Authentifizierung ohne Authentication-Gateway
[id="image-sequenzdiagramm-sgw-without-agw",reftext="{figure-caption} {counter:figures}"]
image::isy-security:konzept/Squenzdiagramm_ServiceGateway_ohne_AuthGateway.dn.svg[align="center"]



[[autorization-grant]]
===== Autorisierungsverfahren

Mit SpringSecurity(OAuth2.0) werden die vier Berechtigungszuteilungsverfahren _Authorization-Code-Credentials_, _Implicit-Credentials_, _Resource-Owner-Password-Credentials_ und _Client-Credentials_ spezifiziert.
In IsyFact spielen davon bei den externen Anwendungsaufrufen über ein _Service-Gateway_ die beiden Verfahren _Resource-Owner-Password-Credential_ und _Client-Credential_ ein Rolle, da es sich hierbei um die Berechtigungszuteilung für ausschließlich _Confidential-Clients_ dreht.

[[resource-owner-password-credential-flow]]
====== Resource-Owner-Password-Credential Flow (Deprecated)

Hinweis: Dieser Flow soll gemäß OAuth2.0 Vorgaben nicht mehr verwendet werden und wird in zukünftigen Versionen aus dem OAuth-Standard entfernt.
Als Nachfolger ist der xref:client-credential-flow[] zu wählen.

Der _Resource-Owner-Password-Credential_-Flow, der als Authentifizierungsdaten die Attribute `Username` und `Passwort` verwendet, sollte nur eingesetzt werden, wenn die involvierte Client-Anwendung ein hohes Vertrauen zur Wahrung der Authentifizierungsdaten sicherstellt oder wenn keine andere Art der Berechtigungszuteilung verfügbar ist.
So wird die Authentifizierung für einen techn. Nutzer über diesen Authorization-Flow abgebildet.

.OAuth2.0 Resource-Owner-Password-Credential Flow
[id="image-resourceowner-password-credential-flow",reftext="{figure-caption} {counter:figures}"]
image::isy-security:konzept/Resource-Owner-Passwort-Credential-Flow.dn.svg[align="center"]

Im vorherigen Bild wird der logische Ablauf des _Resource-Owner-Password-Credential_-Flows dargestellt.
Hierbei wird die Konfiguration des techn. Nutzers als der _Resource-Owner_ dargestellt.

Einem _Confidential Client_ wird die Konfiguration (1.) eines techn. Nutzers mit den Authentifizierungsdaten `Username` und `Passwort` zugeordnet.
Die so konfigurierte (Confidential-Client)-Anwendung schickt (2.) dann diese Authentifizierungsdaten an den IAM-Service.
Im IAM erfolgt mit den so übergebenen Authentifizierungsdaten die Authentifizierung, die im Ergebnis ein gültiges Access-Token als Antwort (3.) zurückgeliefert.
Die Client-Anwendung kann, mit dem so erhaltenen Access-Token, dann ihre Fachanwendungen aufrufen.
Das Access-Token enthält alle notwendigen Daten, um zu verifizieren, ob die aufrufende Anwendung ordnungsgemäß authentifiziert und autorisiert ist.


[[client-credential-flow]]
====== Client-Credential Flow

Der _Client-Credential_-Flow wird und darf nur zur Berechtigungszuteilung eingesetzt werden, wenn die Client-Anwendung selbst auch der Besitzer der Authentifizierungsdaten und damit als Confidential-Client-Anwendung eingestuft ist.
Dieser Credential-Flow ist nach SpringSecurity OAuth2.0 auch die einzige Möglichkeit einen technischen Nutzer (Client) zu authentifizieren.
Es erfolgt hierbei keine Interaktion durch einen Benutzer, der sein Passwort eingeben müsste, sondern die Schritte zur Authentifizierung und Autorisierung der Client-Anwendung laufen selbständig als Hintergrundprozess analog einer Batch-Anwendung ab.
Die dabei verwendeten Authentifizierungsdaten `Client-ID` und `Client-Secret` müssen vor der Nutzung für die Client-Anwendung definiert und mit dem IAM-System abgestimmt sein.

.OAuth2.0 Client-Credential Flow
[id="image-clientcredential-flow",reftext="{figure-caption} {counter:figures}"]
image::isy-security:konzept/Client-Credential-Flow.dn.svg[align="center"]

Im vorherigen Bild wird der logische Ablauf des _Client-Credential_-Flows dargestellt.
Hierbei kann die Client-Anwendung nach einem Access-Token beim IAM anfragen (1.), indem sie dabei ihre eigenen Client-Authentifizierungsdaten oder anderweitig unterstützte Authentifizierungskriterien verwendet.
Die Authentifizierung mit diesen so übermittelten Authentifizierungsdaten erfolgt dann im IAM-Service.
Bei erfolgreicher Authentifizierung wird (2.) ein gültiges Access-Token als Antwort zurückgeliefert.
Mit dem so erhaltenen Access-Token kann die Client-Anwendung dann ihre Fachanwendungen aufrufen.
Das Access-Token enthält alle notwendigen Daten, um zu verifizieren, ob die aufrufende Anwendung ordnungsgemäß authentifiziert und autorisiert ist.


[[ausfuehrung-batch-u-task]]
==== Ausführung Batch & Task
In diesem Kapitel wird beschrieben, wie ein Batch oder wie ein Task mit IsyFact-3 im Zusammenspiel mit SpringSecurity OAuth2.0 abgesichert laufen kann.
Dabei wird im Kapitel xref:absicherung-batch[] das Zusammenspiel des Bausteins `isy-batchrahmen` mit dem neuen Sicherheitsbaustein `isy-security` erläutert, um einen Batch abgesichert ablaufen zu lassen.
Im Kapitel xref:absicherung-task[] folgt dann die Beschreibung wie der Baustein `isy-task` einen abgesicherten Ablauf einer _Aufgabe_ mit dem Baustein `isy-security` durchführt.

[[absicherung-batch]]
===== Absicherung eines Batch
Gemäß der IsyFact-Systemlandschaft - siehe xref:blaupausen:detailkonzept-komponente-batch/master.adoc#grobe-architektur-des-batchrahmens[Grobe Architektur des Batchrahmens] - ist ein Batch teil eines Anwendungssystems und setzt sich - siehe xref:image-awlogbat[Fachliche Architektur eines Batch in der Anwendungslandschaft] - aus den Komponenten (1) Batch-Logik und -Steuerung sowie den dabei eingesetzten (2) Fachkomponenten zusammen.
Da die Absicherung zur Ausführung eines Batches immer ohne User-Interaktionen stattfindet, ist dieser als _ConfidentialClient_ einzustufen, weil er in der Lage sein muss, die notwendige Vertraulichkeit zur Wahrung seiner Anmeldeinformationen sicherzustellen.

.Fachliche Architektur eines Batch in der Anwendungslandschaft
[id="image-awlogbat",reftext="{figure-caption} {counter:figures}"]
image::isy-security:konzept/AnwLogBat.dn.svg[align="center"]

Ein Batch wird über ein Batch-Client oder Startprogramm – meist ein Shellscript, UC4, JobNetz, CronJob, o.ä. – initialisiert und gestartet.
Diese Batch-Clients sind systemseitig dazu berechtigt, den dedizierten Batch auszuführen und damit zu starten.
Somit ruft der Batch-Client die Komponente _Batch-Logik_ in der Nutzungsschicht der Anwendung auf, das die notwendigen Initialisierungen vornimmt.
Genau hier erfolgt frühzeitig die Unterscheidung welcher _Credential_-Flow - der bisher existierende xref:resource-owner-password-credential-flow[] oder der neue xref:client-credential-flow[] - zur Authentifizierung und Autorisierung des Batch verwendet werden soll.

Die Abbildung xref:image-sequenzdiagramm-absicherung-batch[Absicherung eines Batch] stellt den logischen Ablauf zur Absicherung eines Batch skizzenhaft dar.

.Absicherung eines Batch
[id="image-sequenzdiagramm-absicherung-batch",reftext="{figure-caption} {counter:figures}"]
image::isy-security:konzept/Sequenzdiagramm_AbsicherungBatch.dn.svg[align="center"]

Das heißt, in der Batch-Konfiguration ist ein Property konfiguriert, das dahingehend aufgelöst wird, ob der Batch nun mit einem _NatürlichenNutzer_ und den zugehörigen Authentifizierungsdaten `Benutzer` und `Passwort` über den bisherigen xref:resource-owner-password-credential-flow[] oder über den neuen xref:client-credential-flow[] mit dem migrierten _TechnischenNutzer_ mit `Client-ID` und `Client-Secret` authentifiziert und autorisiert wird.

Liegen zu diesem Property noch die zu IsyFact-2 existierenden Authentifizierungsdaten vor, dann erfolgt die Authentifizierung und Autorisierung nach dem bisherigen xref:resource-owner-password-credential-flow[].
Dadurch kann der Batch auf IsyFact-3 umgestellt werden, ohne dass zusätzliche Änderungen im _Credential_-Flow und damit eine vorherige Nutzermigration zu einem _Client_-User im IAM notwendig wäre.

Bei der Initialisierung des Batch werden die Authentifizierungsdaten an die _Batch-Steuerung_ übergeben und dort ausgewertet, um den korrekten _Credential_-Flow zu starten.
Dazu bietet die _Batch-Steuerung_ von _IsyFact-3_ nach wie vor die bisherige API an, um den bisherigen xref:resource-owner-password-credential-flow[] zur Authentifizierung zu nutzen.
Für den neuen xref:client-credential-flow[] existiert in der _Batch-Steuerung_ eine neue zusätzliche API, die die Authentifizierung für einen migrierten _Client_-User durchführt.

Je nach verwendetem _Credential_-Flow erfolgt mit den jeweiligen erhaltenen Authentifizierungsdaten des Batch-Nutzers dann die eigentliche Authentifizierung über den IAM-Service der Plattform.

Zu unterscheiden wäre hierbei noch, wo der Batch innerhalb der Systemlandschaft angesiedelt ist.
Liegt der Batch - wie in xref:image-awlogbat[Fachliche Architektur eines Batch in der Anwendungslandschaft] dargestellt - in der Nutzungsschicht und damit außerhalb des Anwendungskerns, dann muss der Authentifizierungsaufruf zum IAM - wie in Kapitel xref:aufruf-service-gateway[] beschrieben - über das SergiveGateway geroutet werden.
Liegt der Batch aber innerhalb des Anwendungskerns, dann ist der Authentifizierungsaufruf direkt vom Sicherheitsbaustein `isy-security` an das IAM möglich.

Im IAM-Service wird zu den übergebenen _Authentifizierungsdaten_ der dort verwaltete Benutzer ermittelt und validiert.
Bei erfolgreicher Authentifizierung wird aus den Benutzerdaten ein _Access-Token_ generiert.
Dieses Token beinhaltet alle notwendigen Informationen - siehe xref:inhalte-der-token[], um eine Authentifizierung und Autorisierung an den nachfolgenden Aufrufen von Fachkomponenten durchführen zu können.
Das IAM-System liefert das so generierte _Access-Token_ an die aufrufende Komponente zurück.

Im Sicherheitsbaustein _isy-security_ wird zur weiteren Verwendung aus dem _Access-Token_ ein `SecurityContext` initialisiert und aufbereitet, der somit alle notwendigen Informationen wie das _Access-Token_, dem Nutzer zugeordnete Rollen, etc. enthält.
Für die weiteren Prozessschritte im Batch wird dieser `SecurityContext` immer weitergereicht, so dass dieser bei der Ausführung seiner Fachanwendungen sich entsprechend diesen gegenüber authentifizieren und autorisieren kann.

Um sicherzustellen, dass ein Batch über seine gesamte Laufzeit ein gültiges _Access-Token_ besitzt und sich jederzeit an den Fachanwendungen authentifizieren und autorisieren kann, muss in der _Batchsteuerung_ eine Überprüfung des _Access-Tokens_ erfolgen.
Das bedeutet der _isy-batchrahmen_ verfügt mit _IsyFact-3_ innerhalb der Satz-Verarbeitungsschleife über einen Validierungsmechanismus, der bei jedem Durchlauf einer Datensatz-Verarbeitung vor den eigentlichen Aufrufen der Fachanwendungskomponenten die Gültigkeitsdauer des _Access-Tokens_ überprüft.
Diese Prüfung verifiziert, dass das _Access-Token_ noch eine Mindestgültigkeitsdauer aufweist, die über die Batch-Konfiguration vorgegeben werden kann.
Sollte die Gültigkeitsdauer des _Access-Tokens_ kleiner sein als die vorgegebene bzw. konfigurierbare Mindestgültigkeitsdauer, dann aktualisiert die _Batchsteuerung_ das _Access-Token_, indem eine erneute Authentifizierung und Autorisierung gegen das IAM, analog zur Initialisierungsphase des Batch, durchgeführt wird.

Das so erneuerte _Access-Token_ kann nun wieder für ein oder mehrere Verarbeitungszyklen verwendet werden, ohne dass es in den evtl. kaskadierend aufgerufenen Fachanwendungen zu einem Fehler mangels gültigem _Access-Tokens_ kommen kann.

Falls in der _Batch-Logik_ vor bzw. nach der Satz-Verarbeitungsschleife eine umfangreichere vorbereitende bzw. nachbereitende Datenverarbeitung stattfinden sollte, die evtl. auch eine längere Zeit in Anspruch nimmt, dann kann die Logik zur "_Überprüfung der Token-Gültigkeitsdauer mit Authentifizierung und Autorisierung gegen das IAM_" aus der _Batchsteuerung_ auch hier eingesetzt werden.

[[absicherung-task]]
===== Absicherung von Aufgaben (Tasks)

Die in diesem Kapitel beschriebene Absicherung von _Aufgaben_ unterscheidet sich gegenüber eigenständigen _Batch_-Anwendungen dahingehend, dass _Aufgaben_ als integrierter Anteil einer eigentlichen Anwendung definiert sind.
Sie besitzen in der Regel einen kleineren Umfang als _Batches_ und werden nicht manuell von außen gesteuert.
Stattdessen werden sie durch die Anwendung selbst konfiguriert, zeitlich geplant und selbstständig ausgeführt.
Daher müssen _Aufgaben_, als Teil einer Komponente des Anwendungskerns, über andere Mechanismen abgesichert werden.

Mit Einführung des neuen Sicherheitsbausteins `isy-security` werden auch für die Absicherung von _Aufgaben_ beide _Credential_-Flows xref:client-credential-flow[] und xref:resource-owner-password-credential-flow[] unterstützt.
Das bedeutet, dass die für die _Aufgaben_-Authentifizierung verwendete Parametrisierung per KonfigurationsKey einerseits wie bisher als _NatürlicherNutzer_ zu `Benutzer` und `Passwort` und andererseits neu als _TechnischerNutzer_ zu `Client-ID` und `Client-Secret` aufgelöst werden kann.
Mittels der beiden verschiedenen Sets an KonfigurationKeys erfolgt so die Unterscheidung, welcher Credential-Flow im Sicherheitsbaustein durchlaufen wird.

Mit _IsyFact-3_ soll bevorzugt der xref:client-credential-flow[] und den Properties `Client-ID` und `Client-Secret` verwendet werden, da der xref:resource-owner-password-credential-flow[] und den Properties `Benutzer` und `Passwort` mit _SpringSecurity OAuth2.1_ aus der Spezifikation herausgenommen ist.

Zur Unterstützung einer weichen Migration wird mit _IsyFact-3_ der xref:resource-owner-password-credential-flow[] mit `Benutzer` und `Passwort` weiterhin möglich sein, da zum Wechseln des Credential-Flows auch erst eine Migration des _NatürlichenNutzers_ auf einen _TechnischenNutzer_ im IAM abgeschlossen sein muss.

Wird in einer Fachanwendungskomponente die `isy-task`-Bibliothek eingebunden, so kann diese über das interne _SpringBoot-Scheduler_-Framework _Aufgaben_ als abgekoppelte Hintergrundprozesse starten.
Per Konfiguration kann dabei definiert werden, ob eine _Aufgabe_ ohne oder mit Authentifizierungs- und Autorisierungs-Mechanismen ausgeführt wird.

Mit _IsyFact-3_ wird für die _Aufgaben_-Ausführung mit Authentifizierung und Autorisierung zusätzlich der neue xref:client-credential-flow[] eingeführt.
Die Unterscheidung welcher der beiden _Credentials_-Flows, ob xref:resource-owner-password-credential-flow[] oder xref:client-credential-flow[] für die _Aufgabe_ verwendet wird, erfolgt innerhalb der _isy-task_-Bibliothek.
Wie bei einem _Batch_ per `Batch-ID`, wird für eine _Aufgabe_ per `Task-ID` die Definition der Authentifizierungsdaten in der Betriebskonfiguration aufgelöst.
Je nach vorhandenem Set an Authentifizierungsproperties - ob `Benutzer` und `Passwort` oder `Client-ID` und `Client-Secret` - wird der entsprechende _Credential_-Flow in _isy-security_ bestimmt.

Dadurch können auch Aufgaben, deren Nutzer noch nicht zu einem _TechnischenNutzer_ mit `Client-ID` und `Client-Secret` in IAM migriert wurden, weiterhin mit _IsyFact-3_ ausgeführt werden.

In der Abbildung xref:image-sequenzdiagramm-absicherung-task[Absicherung von Aufgaben (Tasks)] wird der logische Ablauf zur Absicherung einer _Aufgabe_ mit dem neuen Security-Baustein `isy-security` im Zusammenspiel mit der Bibliothek `isy-task` skizziert.

.Absicherung von Aufgaben (Tasks)
[id="image-sequenzdiagramm-absicherung-task",reftext="{figure-caption} {counter:figures}"]
image::isy-security:konzept/Sequenzdiagramm_AbsicherungTask.dn.svg[align="center"]

Sobald eine Anwendungskomponente einen fachlichen Ablauf als abgekoppelten Hintergrundprozess und somit als _Aufgabe_ ausführen möchte, startet diese eine Initialisierung der _Aufgabe_ mit der `TaskID` als Parameter.
In `isy-task` wird die übergebene `TaskID` verwendet, um in der Betriebskonfiguration gemäß den xref:isyfact-standards-doku:isy-task:konzept/master.adoc#konfiguration[Task-Konfigurations-Konventionen] nach dem entsprechenden Set an Konfigurationswerten aufzulösen.
Da in jedem Fall die Aufgabe von dem eigentlichen Anwendungsprozess abgekoppelt ablaufen soll, wird ein Scheduler instanziiert.
Je nach vorliegenden Konfigurationswerten für die übergebene `TaskID` startet dann der Scheduler den abgekoppelten _Aufgaben_-Prozess entsprechend zeitlich versetzt oder gar zyklisch wiederholend.
Erst in diesem abgespaltenen _Aufgaben_-Prozess erfolgt dann die Authentifizierung für den Task.

Der gestartete _Aufgaben_-Prozess von `isy-task` ermittelt dann anhand der übergebenen `TaskID` das konfigurierte Authentifizierungsdaten-Set und entscheidet durch diese die entsprechende Authentifizierungsmethode in `isy-security` aufzurufen.
Das bedeutet, für das Authentifizierungsdatenpaar `Benutzer` und `Passwort` ruft der _Aufgaben_-Prozess in `isy-security` die Authentifizierung für den xref:resource-owner-password-credential-flow[] auf.
Und für das Authentifizierungsdatenpaar `Client-ID` und `Client-Secret` erfolgt der Aufruf für den xref:client-credential-flow[].

Der Sicherheitsbaustein `isy-security` gibt die Authentifizierungsdaten an das IAM weiter und erhält von diesem bei erfolgreicher Authentifzierung ein gültiges _Access-Token_ zurück.
Dieses erhaltene _Access-Token_ wird dann von `isy-security` interpretiert und zur weiteren Verwendung ein `SecurityContext` initialisiert und aufbereitet, der somit alle notwendigen Informationen wie das _Access-Token_ selbst, dem Nutzer zugeordnete Rollen, etc. enthält.
Der _Aufgaben_-Prozess erhält dann den initialisierten `SecurityContext` zurück, den er innerhalb seiner weiteren Ablaufschritte immer weiterreicht, sodass dieser sich beim Aufruf seiner Fachanwendungen entsprechend diesen gegenüber authentifizieren und autorisieren kann.


[[verarbeitung-asynchroner-anfragen]]
==== Verarbeitung asynchroner Anfragen

[[token]]
=== Token

[[inhalte-der-token]]
==== Inhalte der Token

[[validierung-der-token]]
==== Validierung der Token

[[bereitstellung-der-tokeninformationen]]
==== Bereitstellung der Tokeninformationen

Das Access-Token wird in den Spring `SecurityContext` übernommen.
Zudem wird der Access-Token als aufgeschlüsseltes JSON-Objekt inklusive aller Claims (Inhalte des Access-Tokens) in der Anwendung innerhalb des `SecurityContexts` bereitgestellt.

Die vom IAM-Service im 'roles'-Claim hinterlegten Rollen des Benutzers werden auf die anwendungsspezifischen Rechte umgesetzt und als `GrantedAuthorities` in den `SecurityContext` eintragen (durch eigene Implementierung von) `JwtGrantedAuthoritiesConverter`).
Der Spring `SecurityContextHolder` hält den `SecurityContext` (in einem `ThreadLocal` Objekt) und der IsyFact `Berechtigungsmanager` kann darüber die Rollen und Rechte des Benutzers abfragen und der Anwendung in Form der Methoden `getRollen`, `getRechte`, `hatRecht`, `pruefeRecht` zu Verfügung stellen.

Weitere Informationen zum angemeldeten Benutzer, wie das Behördenkennzeichen oder seine Benutzerkennung (Anmeldename), kann in der Anwendung aus dem `SecurityContext` mit der Angabe des zugehörigen Claims ausgelesen werden.

Ein direkter Zugriff auf das Access-Token in einer Anwendung sollte nicht geschehen.

[[weitergabe-der-token]]
==== Weitergabe der Token

Um auf eine geschützte Ressource eines anderen Anwendungssystems (Ressourcen-Server) zugreifen zu können, muss die Anwendung in der Anfrage (Request) das Access-Token mitgeben.
Dazu wird es aus dem `SecurityContext` gelesen und - Base64-codiert, wie erhalten - mit in den Header des HTTP-Requests gesetzt.
Genauer gesagt, in das "Authorization" Request-header Feld und mit dem "Bearer" Authentifizierungs-Schema (Authorization: Bearer <accessTokenStringBase64> - Siehe auch:
xref:glossary:literaturextern:inhalt.adoc#litextern-authorization-bearer-token[RFC 6750 Authorization Bearer Token]).

Der Ressourcen-Server liest das Access-Token aus dem Request-Header und gibt - nach Validierung des Access-Tokens und Prüfung des Inhalts (Ablaufdatum, Rechte aus Rollen) - die angeforderte Ressource frei.

[[aktualisierung-der-token]]
==== Aktualisierung der Token

[[nutzung-des-behoerdenkennzeichens]]
=== Nutzung des Behördenkennzeichens

Als zusätzliche Sicherheitsmaßnahme ist zur Authentifizierung im IAM-Service ein Behördenkennzeichen (BHKZN) erforderlich, welches zu dem Behördenkennzeichen passen muss, dass im Nutzerprofil hinterlegt ist.
Das BHKZN wird im HTTP-Header übertragen und aus diesem vom IAM-System ausgelesen.

Wie in xref:konzept/inhalt.adoc#aussensicht-der-komponente-security[Schnittstelle des Bausteins Security] beschrieben, wird bei der Authentifizierung das Behördenkennzeichen als String an den `Authentifizierungsmanager` übergeben.
Zur Authentifizierung von technischen Nutzern mithilfe der Methode `authentifiziereClient()` wird daher die Client-Id, das Client-Secret und das BHKZN übergeben.
Der alternative Weg benötigt die Benutzerkennung (Nutzername), das Passwort und das BHKZN zur Authentifizierung mit der Methode `authentifiziereSystem()`.

[[sicherheitsarchitektur-eines-it-systems]]
== Sicherheitsarchitektur eines IT-Systems

Der Baustein Security bildet eine Komponente des Querschnitts der xref:blaupausen:referenzarchitektur-it-system/master.adoc#einleitung[IsyFact Referenzarchitektur IT-Systeme].
Er ist von jedem IT-System zur Autorisierung von Zugriffen und Vorgängen zu verwenden.

Die Mechanismen zur Absicherung IsyFact-konformer IT-Systeme haben zum Ziel, die Autorisierung von Zugriffen _systematisch_, _einheitlich_ und _einfach_ umzusetzen.

Die *Systematik* und Vollständigkeit der Berechtigungsprüfungen wird dadurch erreicht, dass Berechtigungsprüfungen in den IT-Systemen an definierten Stellen und auf identische Weise stattfinden.

Die *Einheitlichkeit* wird durch Bereitstellung der Bibliothek `isy-security` und Nutzungsvorgaben gewährleistet, die von allen IT-Systemen zu verwenden sind.
Berechtigungsprüfungen erfolgen innerhalb eines IT-Systems immer über die Bibliothek `isy-security`.

Die *Einfachheit* der Nutzung der Bibliothek `isy-security` wird durch weitgehende Transparenz bei der Initialisierung, kompakte Schnittstellen und deklarative (z.B. per Annotation) statt programmatischer Implementierung erreicht.

[[praemissen]]
=== Prämissen

Aus den xref:konzept/master.adoc#prinzipien-der-sicherheitsarchitektur[Prinzipien der Sicherheitsarchitektur] leiten sich die folgenden Randbedingungen für die Umsetzung der Berechtigungsprüfung innerhalb eines IT-Systems ab:

* Anfragen, die am Dialog eines IT-Systems eingehen, sind immer bereits durch das IAM-System bzw. die lokale Authentifizierung erfolgreich  authentifiziert.
Sorgt ein IAM-System für die Authentifizierung, enthält der HTTP-Header der Anfrage die Identifikation des Anwenders und dessen Rollen.
Die Informationen aus dem HTTP-Header werden als `AufrufKontext` in das IT-System übernommen.
* Anfragen, die an einer Service-Schnittstelle eines IT-Systems eingehen, sind ebenso bereits authentifiziert.
Das mit der Anfrage an das IT-System als Parameter übergebene Transportobjekt `AufrufKontextTo` enthält die Identifikation des Anwenders und dessen Rollen und wird als `AufrufKontext` in das IT-System übernommen.
* Prozesse, die unabhängig von eingehenden Anfragen (über Dialog und Service) durch ein IT-System gestartet werden, müssen zunächst einen (meist technischen) Anwender gegen das IAM-System bzw. die lokale Authentifizierung erfolgreich authentifizieren, dessen Rollen ermitteln und diese Informationen als `AufrufKontext` im IT-System hinterlegen.
* Ein innerhalb der Logik- und Verarbeitungszone eines IT-Systems übergebener `AufrufKontext` ist vertrauenswürdig.
Er kann ohne erneute Rückfrage an das IAM-System bzw. die lokale Authentifizierung verwendet werden.

[[software-architektur]]
=== Software-Architektur

Die folgende Abbildung zeigt den logischen Aufbau für die Authentifizierung und für die Bereitstellung von Berechtigungsinformationen an die Komponenten eines IT-Systems.

.Software-Architektur der Berechtigungsprüfung
[id="image-Berechtigungspruefung",reftext="{figure-caption} {counter:figures}"]
image::isy-security:konzept/software-architektur-berechtigungspruefung.png[align="center"]

Im Folgenden werden die Aufgaben und grobe Funktionsweise der Komponenten für die Autorisierung von Anfragen in einer xref:glossary:glossary:master.adoc#glossar-geschaeftsanwendung[Geschäftsanwendung]  erläutert.

Der Baustein `isy-security` basiert auf dem Framework Spring Security und bietet querschnittliche Funktionalität zur Authentifizierung und Autorisierung (Berechtigungsprüfung) von Anfragen.
Um IsyFact-spezifische Anforderungen, wie z.B. die Nutzung des Behördenkennzeichens, zu erfüllen, existiert eine Zugriffsschicht, die eben diese Funktionalität bereitstellt und den Zugriff auf Spring Security kapselt.
Die einheitliche Zugriffsschicht für Authentifizierung und Autorisierung erleichtert zudem, durch die teilweise Übernahme bestehender Schnittstellen, die Migration von einer älteren IsyFact Version.
Die Authentifizierung und Autorisierung an der Benutzeroberfläche findet im Zuge der Einführung von Single-Page-Applications (SPAs) nicht mehr über das Backend oder den Baustein isy-security statt.

Der Zugriff auf den Baustein erfolgt über das Interface `Security`, das mehrere Manager bereitstellt:

* `Authentifizierungsmanager`
* `Berechtigungsmanager`

Das Interface `Security` hat Zugriff auf eine Liste von allen im System hinterlegten Rollen.
Das Anwendungssystem greift darüber auf den `Authentifizierungsmanager` und den `Berechtigungsmanager` zu.

Der `Authentifizierungsmanager` ist für die Kommunikation mit dem IAM-Service über den `OAuth2AuthorizedClientProvider` zuständig.
Die Authentifizierung (Anmeldung) verläuft über diesen Aufruf.
Nach einer erfolgreichen Authentifizierung erfolgt der Erhalt des Access-Tokens und der dem Benutzer zugeordneten Rollen.
Diese Informationen werden anschließend im `SecurityContext` abgelegt.

Über den `Berechtigungsmanager` kann die Anwendung die Rollen und anwendungsspezifischen Rechte des angemeldeten Benutzers abfragen.

Der `RolePrivilegeGrantedAuthoritiesConverter` ist für die Konvertierung vom IAM-Service im Access-Token übermittelten Rollen des Benutzers in die anwendungsspezifischen Rechte zuständig.

Mit der von Spring Security bereitgestellten Annotation `@secured` werden angebotene Services und Methoden der Anwendung abgesichert.
Dieser Annotation muss noch der Name eines anwendungsspezifischen Rechts mitgegeben werden.
Im Interceptor `SecuredInterceptor` wird sichergestellt, dass nur dann der Zugriff gewährt wird, wenn der angemeldete Nutzer auch über das vorhandene anwendungsspezifische Recht verfügt.

Hinweis: Die Annotation `@secured` löst die Annotation `@gesichert` ab und ist analog dazu verwenden.

Der `NutzerAuthentifizierunginterceptor` ist für die Authentifizierung von technischen Nutzern zuständig und wird über eine Annotation (`@NutzerAuthentifikation`) bereitgestellt.
Parallel zur Annotation `@NutzerAuthentifikation` existiert die Annotation `@ClientAuthentification` zur Authentifizierung von OAuth2.0 Clients.
Dies ermöglicht die Umstellung von technische Nutzer auf OAuth2.0 Clients, ohne große Auswirkungen im Anwendungssystem zu erzeugen.
Die Authentifizierungsdaten werden aus der Konfiguration der Anwendung ausgelesen und zur Authentifizierung verwendet.
Die Authentifizierung findet über die Implementierung des Interfaces `Authentifizierungsmanager` statt.
Das Ergebnis einer Authentifizierung über die Annotationen `@ClientAuthentification` und `@NutzerAuthentifikation` ist ein voll initialisierter `SecurityContext` mit einem validen Access-Token.

[[aussensicht-der-komponente-security]]
=== Schnittstelle des Bausteins Security

Im Folgenden wird die Schnittstelle des Bausteins `isy-security` beschrieben.

.Schnittstelle des Bausteins Security
[id="image-schnittstelle-security",reftext="{figure-caption} {counter:figures}"]
image::konzept/security-schnittstellen.dn.svg[align="center"]

Das Interface `Security` ist der zentrale Einstiegspunkt in den Baustein `isy-security`.
Bei seiner Instanziierung wird die anwendungsspezifische Rollen-Rechte-Datei eingelesen und damit der `Authentifizierungsmanager` sowie der `Berechtigungsmanager` erzeugt.
Das Interface `Security` stellt der Fachanwendung die im weiteren beschriebenen `Authentifizierungsmanager` und `Berechtigungsmanager` der Fachanwendung zur Verfügung.
Außerdem kann die Fachanwendung über die Methode `getAlleRollen` eine Liste von allen im System hinterlegten Rollen erhalten.

Der `Authentifizierungsmanager` übernimmt die Authentifizierung von technischen Nutzern am IAM-System.
Mit der Methode `authentifiziereClient` wird die OAuth2.0-konforme Authentifizierung eines Client mittels Client-ID u. Client-Secret unterstützt und mit der Methode `authentifiziereSystem` der alternative Weg mittels (techn.) Nutzername u. Passwort.
Bei erfolgreicher Authentifizierung werden die vom IAM-System zurückgegebenen Daten (Access-Token, Rollen des Anwenders, ...) im `Spring SecurityContext` abgelegt.
Dort werden auch die den aus den Rollen resultierenden Rechte des Anwenders gespeichert.
Eine nicht erfolgreiche Authentifizierung (fachliche Ablehnung oder technisches Problem) löst eine `AuthentifizierungFehlgeschlagenException` bzw. `AuthentifizierungTechnicalException` aus.

Der `Berechtigungsmanager` gibt Auskunft über die Rollen und Rechte des Anwenders.
Die in der Benutzeradministration dem Anwender zugewiesenen Rollen werden mithilfe einer anwendungsspezifischen Rollen-Rechte-Datei in konkrete Rechte des Anwenders für diese Anwendung umgewandelt.
Die aktuellen Rollen und Rechte des Anwenders können mit den Methoden des `Berechtigungsmanager` erfragt werden und es kann geprüft werden, ob der Anwender ein bestimmtes Recht hat.
Die Methoden `getRechte` und `getRollen` liefern die aktuell dem Anwender zugeordneten Rechte bzw. Rollen.
Mit der Methode `hatRecht` kann die Anwendung feststellen, ob der Anwender aktuell ein bestimmtes Recht besitzt, während mit `pruefeRecht` der nachfolgende Code mit dem angegebenen Recht abgesichert wird: falls der Anwender das Recht nicht hat, wird eine `AutorisierungFehlgeschlagenException` geworfen.
Mit diesen Berechtigungsabfragen kann die Fachanwendung z.B. feingranular bestimmen, ob und wie der Anwender bestimmte Daten sehen oder bearbeiten kann bzw. ob und wie er bestimmte Funktionen der Anwendung benutzen kann.

[[aufruf-von-nachbarsystemen]]
=== Aufruf von Nachbarsystemen

So wie ein IT-System bei einem Aufruf erwartet, einen gültigen, vollständigen Aufrufkontext vorzufinden, erwartet dies auch ein Nachbarsystem, welches vom eigenen IT-System aufgerufen wird.
Das aufrufende System muss daher einen Aufrufkontext mitliefern.
Im Regelfall soll dabei der Aufrufkontext der originären Anfrage verwendet und unverändert weitergeleitet werden.

Zum Aufruf von Nachbarsystemen sollen, falls vorhanden, dedizierte Client-Bibliotheken verwendet werden.
Diese enthalten bereits die Logik zur Weiterleitung des Aufrufkontextes.

Gibt es diese nicht, muss das Nachbarsystem direkt aufgerufen werden.
Hierbei muss das aufrufende IT-System stets ein entsprechendes Transportobjekt befüllen und mit dem Aufruf an das Nachbarsystem übergeben.
Für die Technologie Spring HTTP Invoker stellt die IsyFact passende Transportobjekte in der Bibliothek `isy-serviceapi-sst` bereit.


[[rollen-und-rechte]]
== Rollen & Rechte

Die Vergabe von Rollen ist _das_ Mittel der Benutzeradministration, um Anwender der xref:glossary:glossary:master.adoc#glossar-anwendungslandschaft[Anwendungslandschaft] mit Berechtigungen auszustatten.
Die Vergabe von Rollen an einen Anwender (menschlicher und technischer) erfolgt im Querschnitt:
in der Querschnittsanwendung Benutzerverzeichnis.

Es ist konzeptionell beabsichtigt, dass die Administration per Rollen recht grobgranular erfolgt.
Eine administrative Vergabe feingranularer Rechte ist konzeptionell nicht erwünscht.
Die individuelle Zuordnung von Rechten zu Anwendern ist daher prinzipiell nicht möglich.
Rechte werden Anwendern ausschließlich indirekt über Rollen zugeordnet.
Welche Rechte einer Rolle zugeordnet sind, wird innerhalb der statischen Konfiguration eines IT-Systems definiert und ist damit Teil der Software.

====
Die Geschäftsanwendung X bietet zwei Dialoge zur Administration von Anwendungseigenschaften.
Die Dialoge sind über die Rolle `AnwendungX_Administrator` abgesichert.
Innerhalb der Anwendung ist Dialog 1 mit dem Recht `AdministrierenDialog1` und Dialog 2 mit dem Recht `AdministrierenDialog2` abgesichert.
Grobgranular wird die Rolle `AnwendungX_Administrator` einem Anwender zugeordnet.
Innerhalb der Konfiguration des IT-Systems X sind beide Rechte konfiguriert und der Rolle `AnwendungX_Administrator` zugeordnet.
Alle Anwender mit der Rolle `AnwendungX_Administrator` sind somit innerhalb der Anwendung autorisiert, die beiden Admin-Dialoge zu verwenden.
====

Der Vorteil an diesem Vorgehen ist, dass Änderungen an der Zuordnung von Anwendern zu Rollen oder von Rollen zu Rechten nur zu lokalen Änderungen führen.
Soll eine Rolle andere Rechte in einer Geschäftsanwendung bekommen (z.B. durch das Hinzufügen neuer Dialoge), so kann dies für die Benutzeradministration transparent geschehen.
Ebenso sind Änderungen an Anwendern oder ihren zugehörigen Rollen transparent für einzelne Geschäftsanwendungen.

[[spezifikation-der-rollen]]
=== Spezifikation der Rollen

Rollen werden bereits auf fachlicher Ebene als Teil der Systemspezifikation einer Geschäftsanwendung spezifiziert.
Dazu werden zunächst in geeigneter Granularität Rechte definiert, die zur Benutzung bestimmter Funktionalität der Geschäftsanwendung berechtigen.
Diese Rechte werden fachlichen Rollen zugeordnet, die dann wiederum den Anwendern der Anwendung zugeordnet werden können.
Die fachlichen Rollen ermöglichen in der Regel pauschal den Zugriff auf die Geschäftsanwendung oder, im Sinne der Rolle eines fachlichen Sachbearbeiters, die Nutzung ausgewählter Anwendungsfälle.

[[struktur-einer-rolle]]
=== Struktur einer Rolle

Alle Rollen besitzen die folgende Struktur:

*Name:* Interner Name der Rolle, wie er für die Autorisierung und innerhalb von Anwendungen zur Überprüfung bereitgestellt wird.

*Label:* Name der Rolle, wie sie in der Oberfläche der Benutzeradministration angezeigt wird.
In der Regel ist dieser Name identisch mit dem technischen Namen der Rolle.
Eine Abweichung ist nur dann sinnvoll, wenn die Vergabe der Rollen durch den Administrator dadurch intuitiver wird.

*Beschreibung:* Eine kurze Beschreibung der Rolle in einer fachlichen Sprache, die für die Benutzeradministration verständlich ist.

*Typ:* Eine Rolle kann fachlich oder technisch sein.
Nur fachliche Rollen können über die Benutzeradministration verwaltet werden.
Technische Rollen können fachlichen Rollen allerdings untergeordnet werden (siehe weiter unten: *Untergeordnete Rollen*).

*Enthaltene Rechte:* Die Ausstattung einer fachlichen Rolle mit Rechten beschreibt den Funktionsumfang, den diese Rolle bei Nutzung der Geschäftsanwendung ermöglicht.

*Untergeordnete Rollen:* Optional können fachliche Rollen untergeordnete technische Rollen besitzen.
Dies ist z.B. immer dann notwendig, wenn ein Anwendungsfall die Services eines Nachbarsystems verwendet.
Somit muss im Rahmen des Anwendungsfalls die Service-Schnittstelle des Nachbarsystems aufgerufen werden.
Die dazu benötigte, technische Rolle muss der fachlichen Rolle untergeordnet werden, damit dies funktioniert.

*Sichtbarkeit der Rolle:* Die Sichtbarkeit der Rollen bei der Zuordnung an Anwender, externe Systeme und interne Systeme kann eingeschränkt werden, um die Administration zu vereinfachen.

Die meisten Rollen sind fachlicher Natur.
Technische Rollen treten oft im Rahmen von Service-Schnittstellen auf.
Bietet eine Geschäftsanwendung Funktionalität über Service-Schnittstellen an, so ist die Nutzung jeder Service-Schnittstelle zumindest durch eine technische Rolle abzusichern.
Diese Rollen werden nicht direkt an Anwender vergeben, sondern fachlichen Rollen anderer Geschäftsanwendungen untergeordnet.

Wenn die Anwendung fachliche oder technische Batches enthält, dann müssen für diese Batches in der Spezifikation entsprechende „interne Systeme“ definiert werden.
Die Systemnamen sollten dem folgenden Schema entsprechen: `<Anwendungskürzel>_BAT_<Batchname>`.
Für jedes dieser internen System müssen eigene fachliche Rollen definiert werden.

[[richtlinien-zum-schnitt-der-rollen]]
=== Richtlinien zum Schnitt der Rollen

Zum Schnitt von fachlichen und technischen Rollen gibt es Erfahrungswerte, welche das restliche Kapitel detailliert.
Wichtig ist vor allem die Beziehung zwischen fachlichen und technischen Rollen.
Des weiteren sollte die Menge der Rollen so klein wie möglich gehalten werden.

Die Abbildung xref:image-rollen-beziehungen[] verdeutlicht den Inhalt der folgenden Abschnitte grafisch.

.Beziehungen zwischen fachlichen und technischen Rollen
[id="image-rollen-beziehungen",reftext="{figure-caption} {counter:figures}"]
image::konzept/rollen-beziehungen.png[align="center",pdfwidth=70%,width=70%]

[[technische-rollen]]
==== Technische Rollen

Technische Rollen sichern die Kommunikationswege innerhalb der Anwendungslandschaft ab.
Sie werden für die Schnittstellen von Geschäftsanwendungen verwendet, welche nur von anderen Geschäftsanwendungen aufgerufen werden.


Technische Rollen berechtigen zur Ausführung der entsprechenden Services der Geschäftsanwendung selbst, sowie aller dadurch mittelbar ausgelösten Aktionen in nachgelagerten Anwendungen.
Daher werden diesen technischen Rollen im Regelfall weitere technische Rollen untergeordnet sein, welche die nachgelagerten Anwendungen absichern.

[[technische-zugangsrollen]]
==== Technische Zugangsrollen

Anwender gelangen in der Regel entweder über das xref:glossary:glossary:master.adoc#glossar-portal[Portal] oder den xref:glossary:glossary:master.adoc#glossar-service-gateway[Service-Gateway] in eine Anwendungslandschaft.
Um den Zugriff über diese Schnittstellen zentral und einfach zu verwalten, können dafür entsprechende technische Rollen definiert werden (z.B. `Zugang_Portal` und `Zugang_Service_Gateway`).
Diese Rollen können dann einfach fachlichen Rollen untergeordnet werden, um den jeweiligen Zugriff zu erlauben.

[[technische-querschnitts-rolle]]
==== Technische Querschnitts-Rolle

Für xref:glossary:glossary:master.adoc#glossar-service-fachlich[Services] des Querschnitts, die nahezu alle Aufrufe benötigen und die keine sicherheitskritischen Operationen anbieten, kann eine zentrale Rolle (z.B. `Querschnitt_Nutzer`) angelegt werden.
Diese Rolle berechtigt zur Durchführung von unkritischen Operationen im Querschnitt, wie beispielsweise dem Auslesen von Schlüsselwerten.

Wenn die Querschnitts-Rolle den Zugangsrollen untergeordnet ist, darf jeder Anwender mit Zugriff automatisch auch auf den Querschnitt zugreifen.
Dies reduziert die Anzahl der Rollen, die einem Nutzer zugewiesen sind, in der Regel deutlich.

[[fachliche-rollen]]
==== Fachliche Rollen

Fachliche Rollen werden für Schnittstellen von Geschäftsanwendungen vergeben, welche Zugänge zur Anwendungslandschaft geben.
Dies beinhaltet neben den Dialogen (der grafischen Oberfläche) und Zugängen über den Service-Gateway auch interne Systeme wie beispielsweise Systemtasks oder Batches.


Fachliche Rollen berechtigen zur Ausführung der entsprechenden Aktion über den entsprechenden Zugangsweg, sowie aller dadurch mittelbar ausgelösten Aktionen in nachgelagerten Anwendungen.
Daher werden diesen fachlichen Rollen im Regelfall weitere technische Rollen untergeordnet sein, welche die nachgelagerten Anwendungen absichern.

Fachliche Rollen können über die Benutzeradministration verwaltet und Anwendern bzw. Systemen zugeordnet werden.
Hierbei ist darauf zu achten, dass die Labels der Rollen sinnvoll genutzt werden.

[[richtlinien-zur-benennung-der-rollen]]
=== Richtlinien zur Benennung der Rollen

Die Benennung von Rollen muss fachlich getrieben sein.
Das bedeutet vor allem, dass Rollen für eine fachliche Operation, d.h. den Akteur, angelegt werden.
Grundsätzlich gilt, dass die Namen der Rollen ausgeschrieben werden, sofern sie nicht zu lang werden.
Ist dies der Fall, sollte der Namen abgekürzt und ein sprechendes Label für die Administration der Rollen vergeben werden.

[[fachliche-rollen-schema]]
==== Fachliche Rollen

Das Schema zur Benennung einer fachlichen Rolle für Anwender kann folgendermaßen aussehen:

 <Fachlicher Systemname>_<Funktion>

Der fachliche Systemname beschreibt die Geschäftsanwendung, bzw. die Anwendungsdomäne, in welcher die entsprechende Funktionalität bereitgestellt wird.
Er entspricht prinzipiell dem Systemnamen der Systemspezifikation, abzüglich technischer Kürzel.
Die Rolle zur Verwendung der Schnittstelle Auskunft der Geschäftsanwendung Terminfindung lautet nach diesem Schema: `Terminfindung_Auskunft`.

Da die Rollen für fachliche Operationen angelegt werden, sollten sie unabhängig von technischen Aspekten gelten.
So kann beispielsweise die Rolle `Terminfindung_Auskunft` unabhängig davon gelten, ob die Auskunft über ein Service-Gateway oder das Portal durchgeführt wird.
Dies kann durch die Verwendung spezieller technischer Rollen (s. xref:konzept/master.adoc#technische-zugangsrollen[Technische Zugangsrollen]) erreicht werden.

xref:glossary:glossary:master.adoc#glossar-it-system[IT-Systeme] werden intern in Form von Batches oder Timer-Tasks aktiv.
Auch hier findet ein Zugang zur Anwendungslandschaft statt.
Das Schema zur Benennung einer fachlichen Rolle für IT-Systeme kann folgendermaßen aussehen:

 <Fachlicher Systemname>_SYSTEM_<Suffix>

Im Regelfall gibt es nur eine fachliche Rolle pro IT-System, die alle Batches und Tasks absichert (Beispiel analog zu oben: `Terminfindung_SYSTEM`).
Gibt es beispielsweise mehrere Batches in einer Anwendung, so sollten die einzelnen Batches mit verschiedenen Rechten abgesichert werden, die alle derselben Rolle zugeordnet sind.
Falls mehrere differenzierte Rollen fachlich erforderlich sind, werden die Rollen um ein entsprechendes Suffix ergänzt.
Dies kann der Fall sein, wenn es fachlich unterschiedliche Nutzer von Tasks und Batches gibt.
Zusätzlich dazu kann es erforderlich sein, einen (technischen) Anwender anzulegen, welchem die entsprechenden Rollen zugeordnet werden.

[[technische-rollen-schema]]
==== Technische Rollen

Das Schema zur Benennung einer technischen Rolle kann folgendermaßen aussehen:

 <Technischer Systemname>_<Servicename>

Die Namen technischer Rollen enthalten keine festen Bestandteile wie z.B. `SYSTEM`, da es sich immer um Services handelt.
Der Servicename muss eindeutig und sprechend sein; vor allem, wenn mehrere Services mit derselben Rolle gemeinsam abgesichert werden.
Da die Rollen nur innerhalb der Anwendungslandschaft zum Einsatz kommen und nicht administriert werden müssen, wird der technische Systemname verwendet.
Die Rolle zur Verwendung der Schnittstelle "Eintragen der Teilnahme" der Geschäftsanwendung Terminfindung lautet nach diesem Schema: `Terminfindung-FA_TeilnahmeEintragen`.
Auch hier sollte auf die Länge des Namens geachtet werden und im entsprechenden Fall, wie bei fachlichen Rollen, eine Abkürzung des Namens mit sprechendem Label vorgenommen werden.

[[entwurf-von-rollen]]
=== Entwurf von Rollen

Wird ein neues IT-System entwickelt, sind die oben genannten Richtlinien zum Schnitt und zur Benennung der Rollen stärkstens empfohlen.
Hierfür ist eine enge Abstimmung mit der Benutzeradministration und den jeweiligen fachlichen Ansprechpartnern erforderlich.
Alle Parteien verfügen über unterschiedliches, sich ergänzendes Fachwissen, das essenziell für die Erstellung von Rollen ist.

Prinzipiell sollten so wenig Rollen wie möglich und so viele wie nötig vergeben werden.
Der folgende Prozess bietet eine grobe Richtlinie:

. Jede Schnittstelle wird mit einem Recht abgesichert.
. In Abstimmung mit den fachlichen Ansprechpartnern und der Benutzeradministration werden diese Rechte zu technischen bzw. fachlichen Rollen zusammengefasst.

.Absicherung durch Rechte und Aggregation in Rollen
[id="image-rollen-erstellung",reftext="{figure-caption} {counter:figures}"]
image::konzept/rollen-erstellung.png[align="center",pdfwidth=70%,width=70%]]

[start=3]
. In Abstimmung mit den fachlichen Ansprechpartnern und der Benutzeradministration wird ermittelt, ob und welche zusätzlichen technischen Anwender benötigt werden.
. Vorbereitung der Einspielung der neuen, fachlichen Rollen in die Benutzeradministration.
Über das jeweilige Format bestimmt der IsyFact-Baustein, der zur Benutzeradministration eingesetzt wird.

Die Rollen und Rechte sollten bereits während der Erstellung des Systementwurfs entworfen werden, soweit dies möglich ist.
Sobald die angebotenen Schnittstellen bekannt sind, können die entsprechenden Rollen nach obigen Richtlinien erstellt werden.
Die zugehörigen untergeordneten Rollen lassen sich durch die aufgerufenen Nachbarsystemschnittstellen ermitteln.

[[tests-und-inbetriebnahmen]]
=== Tests und Inbetriebnahmen

Eine wesentliche Einschränkung der bisherigen Modellierung findet sich bei Tests und Inbetriebnahmen.
Es gestaltet sich bislang schwer, dass vor der eigentlichen Inbetriebnahme nur eine kleine Menge von Anwendern auf eine neue Geschäftsanwendung zugreifen kann.
So werden oft, auch bei der Ablösung einer Geschäftsanwendung durch eine neue Umsetzung, komplett neue Rollen für die neue Geschäftsanwendung vergeben, um die Absicherung beider Geschäftsanwendungen zu gewährleisten.
Dies führt oft zu aufwendigen Migrationen und zu einer stark ansteigenden Menge von Rollen.

Um dies zu vermeiden, kann eine neue fachliche Rolle für eine Art Testmodus eingeführt:

 Tester_<Vorhaben>

Geschäftsanwendungen, die bestehende Geschäftsanwendungen ablösen oder vor der offiziellen Inbetriebnahme einer kleinen Menge von Anwendern zur Verfügung stehen, müssen in ihrer betrieblichen Konfiguration einen Schalter besitzen, der einen Testmodus aktiviert.
Ist der Schalter (und damit der Testmodus) aktiv, wird zusätzlich zur üblichen Autorisierung auf die zusätzliche, fachliche Rolle geprüft.
Somit ist sichergestellt, dass beim Ablösen von alten Geschäftsanwendungen auch die neue Geschäftsanwendung mit denselben Rollen abgesichert und (falls nötig) parallel betrieben werden kann.
Genauso funktioniert auch das Freischalten einer neuen Geschäftsanwendung für einen zunächst kleinen Kreis von Anwendern.
In beiden Fällen muss zur eigentlichen Inbetriebnahme, anstatt einer aufwändigen Migration, nur ein Schalter in der betrieblichen Konfiguration umgelegt werden.

// end::inhalt[]